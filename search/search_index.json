{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-zipreport-documentation","title":"Welcome to ZipReport documentation","text":"<p>ZipReport is a python library to aid the generation of visually appealing PDF documents from HTML templates. It combines Jinja2 template capabilities with PDF generation powered by a headless Chromium browser daemon. By leveraging the browser rendering capabilities, it is possible to use CSS and JS for composition of the document, just as if it was any other web page. Available polyfills such as paged.js can be used to generate headers, footers, page numbers, chapter numbers and even table of contents. It is also possible to generate graphics using popular JS libraries, such as d3js, or even embed runtime-generated graphics generated via Python functions.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Design reports in HTML using Jinja templates;</li> <li>Reports are packaged on a single file for easy reuse/distribution;</li> <li>Pluggable rendering backends;</li> <li>Full support for CSS3 and client-side Javascript (when using zipreport-server);</li> <li>Page numbers, headers, footers, ToC, etc. via polyfills (using  paged.js);</li> <li>Jinja tags for dynamic image generation in Python;</li> <li>CLI utility to aid development and packaging of reports;</li> <li>MIME multipart email message generation (with all local resources embedded on a single message);</li> </ul>"},{"location":"#zipreport-samples","title":"ZipReport Samples","text":"<ul> <li>example code is available in examples</li> <li>report template files are available in reports</li> <li>paged.js examples are available in  reports</li> </ul> <p>Available samples:</p> <ul> <li>Simple report - Simple report demonstrating Jinja templating</li> <li>Dynamic image heneration - Report demonstrating server-side dynamic image generation</li> <li>MIME newsletter example - MIME report example</li> <li>paged.js report - Complex report with front page, ToC, page numbers, chapters, server-side images and client-side images;</li> <li>paged.js dynamic ToC - Report showcasing automatic ToC generation</li> </ul>"},{"location":"build_templates/","title":"Building Templates","text":""},{"location":"build_templates/#template-design-considerations","title":"Template design considerations","text":"<p>Typical report template design will require external resources, such as Javascript libraries and web fonts. These resources can be added locally or referenced externally from eg. CDNs, as any regular web page. However, keep in mind that referencing external resources may pose a security risk, and requires internet access when generating PDFs.</p> <p>Having these resources locally will reduce the PDF rendering time and minimize or eliminate the need to have internet access, but will increase the packaged report size and the effort required to maintain reports. Some assets may also have licensing limitations that prevent usage and redistribution in a packaged format.</p> <p>The recommended approach depends on the use case. Reports where PDF rendering time is not critical can reference resources externally as needed; Reports where rendering time is critical (such as generated in response to a user interaction) should have these resources referenced locally, as much as possible.</p>"},{"location":"build_templates/#zipreport-jinja-considerations","title":"ZipReport Jinja considerations","text":"<p>ZipReport allows most Jinja features, including adding your own filters. However, you can only import templates within your report folder path (including subfolders). Adding extensions to Jinja is also supported, when using the JinjaRender class directly. It works by instantiating zipreport.template.JinjaRender with the required options:</p> <pre><code>from zipreport.report import ReportFileLoader\nfrom zipreport.template import JinjaRender\n\n# load report from file\nzpt = ReportFileLoader.load(\"simple.zpt\")\n\n# extensions for jinja usage\njinja_options = {\n    \"extensions\": ['jinja2.ext.i18n'],\n}\n\n# initialize JinjaRender() with the desired options\nrenderer = JinjaRender(zpt, jinja_options)\n</code></pre>"},{"location":"build_templates/#css-considerations","title":"CSS considerations","text":"<p>When using zipreport-server, be aware that the media type print will be used for PDF generation.</p>"},{"location":"build_templates/#waiting-for-javascript-execution-before-rendering","title":"Waiting for JavaScript execution before rendering","text":"<p>Some reports may contain complex JavaScript logic for page composition, and timing the finalization of these operations are a challenge. ZipReport provides a more reliable alternative to relying on waiting a predefined amount of time before triggering the render - a JavaScript event notification system that explicitly notifies the supervisor application that client-side rendering is finalized and PDF generation can be done.</p> <p>The notification mechanism works by writing the string 'zpt-view-ready' to the console. As an example, this can be used to signal paged.js end of operations:</p> <pre><code>&lt;!DOCTYPE html PUBLIC&gt;\n&lt;html lang=\"en\" lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;script src=\"https://s3.amazonaws.com/pagedmedia/pagedjs/dist/paged.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n// custom paged.js handler\nclass handlers extends Paged.Handler {\nconstructor(chunker, polisher, caller) {\nsuper(chunker, polisher, caller);\n}\n\nafterPreview(pages) {\n// event signaling readiness for PDF generation\nconsole.log('zpt-view-ready')\n}\n}\n\n// Register handler on paged.js library\nPaged.registerHandlers(handlers);\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n</code></pre>"},{"location":"build_templates/#generating-images-dynamically","title":"Generating images dynamically","text":"<p>ZipReport provides several filters that allow the generation and inclusion of images generated in runtime, without requiring client-side composition. This is quite useful to add data-driven graphics to the reports, both for PDF and MIME generation.</p> <p>The image is generated by calling a function that will save the results to a io.BytesIO memory buffer. This buffer will be added to the in-memory representation of the report file as an image with a random name by the filter, and then the appropriate html image tag will be generated, for rendering purposes.</p>"},{"location":"build_templates/#bundled-jinja-filters-for-images","title":"Bundled Jinja filters for images","text":"Filter name Description png Generates dynamic PNG image gif Generates dynamic GIF image jpg Generates dynamic JPEG image svg Generates dynamic SVG image <p>Call syntax:</p> <pre><code>Positional args:\n    {{ callable | filter(data_source, alt_text, width, height, css_class }}\n\nNamed args:\n    {{ callable | filter(data=data_source, alt=alt_text, width=width, height=height, class=css_class }}\n</code></pre> <p>Where:</p> Name Description callable function that will generate the specific graphic; it is passed as a template variable filter bundled jinja filter to generate the appropriate img tag; see below for available filters data_source variable with data to be passed to the callable as a parameter alt_text optional img tag alt text width optional image tag width height optional image tag height css_class optional image tag css classes"},{"location":"build_templates/#writing-an-image-generation-function-for-an-image-filter","title":"Writing an image generation function for an image filter","text":"<p>Writing a function to be used dynamically in the report is quite simple; it is a regular function that receives an argument and returns a io.BytesIO buffer object.</p> <p>Below we'll see a complete example on how to generate and embed a simple image on a template. The complete code is available on the examples/filter_simple folder.</p> <p>Example file list:</p> <pre><code>sample_report/index.html\nsample_report/manifest.json\nmain.py\n</code></pre> <p>We start with a simple html template and a manifest file into the sample_report folder:</p> <p>Html template (index.html):</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Zipreport jinja filter example&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;PNG Example&lt;/h1&gt;\n{{ colored_rectangle_fn|png(rectangle_color, \"label for png\") }}\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Manifest file(manifest.json):</p> <pre><code>{\n\"author\": \"zipreport\",\n\"title\": \"Jinja Filter example\",\n\"description\": \"Dynamic jinja filter example\",\n\"version\": \"1.0\",\n\"params\": [\n\"colored_rectangle_fn\",\n\"rectangle_color\"\n]\n}\n</code></pre> <p>We can now build the report:</p> <pre><code>$ zipreport build sample_report\n\n== Building Report simple_report.zpt ==\nChecking manifest &amp; index file...\nBuilding...\nCopying manifest.json...\nCopying index.html...\nGenerating simple_report.zpt...\nDone!\n</code></pre> <p>Then, we start writing our main.py code. First, we create our image generation function. This function will generate a png colored rectangle using PIL, based on the specified color passed as argument (in this case, the value will come from the rectangle_color template variable), and returns a io.BytesIO buffer.</p> <pre><code>import io\nfrom PIL import Image\n\n\ndef render_image(color='red') -&gt; io.BytesIO:\n    # generate a rectangle with the specified color\n    img = Image.new('RGB', (256, 256), color=color)\n    # save generated image to a memory buffer\n    buffer = io.BytesIO()\n    img.save(buffer, format='PNG')\n    # rewind to the beginning of the buffer\n    buffer.seek(0)\n    return buffer\n</code></pre> <p>Lastly, we add some boilerplate to load, process and save the report. This example relies on zipreport-server for rendering (Some additional validations were omitted for readability):</p> <pre><code>if __name__ == \"__main__\":\n\n    args = sys.argv[1:]\n    pdf_name = Path(args[0])  # output file path\n\n    report_name = \"simple_report.zpt\"\n    report = ReportFileLoader.load(report_name)\n\n    # template variables\n    report_data = {\n        # our callback function to generate the image\n        'colored_rectangle_fn': render_image,\n        # desired color to use\n        'rectangle_color': 'pink',\n    }\n\n    # render using zipreport-cli processor\n    result = ZipReport(\"https://127.0.0.1:6543\", \"somePassword\").render_defaults(report, report_data)\n    if not result.success:\n        print(\"An error occured while generating the pdf:\", result.error)\n        exit(1)\n\n    # save io.BytesIO buffer to file\n    with open(pdf_name, 'wb') as f:\n        f.write(result.report.read())\n</code></pre> <p>We can now run our example program:</p> <pre><code>$ python3 main.py result.pdf\nReport generated to result.pdf\n$\n</code></pre> <p>Expected result contents:</p> <p></p>"},{"location":"build_templates/#using-placeholders-for-previewing-purposes","title":"Using placeholders for previewing purposes","text":"<p>Due to the dynamic nature of the dynamic image generation, it is not possible to preview the report correctly with zipreport debug. To work around this limitation, it is possible to specify a placeholder image (local or remote) instead of the callable parameter. The data source parameter, while mandatory, is ignored.</p> <p>Following on the previous example, we can add a data.json to simple_report1 with a string url for an image instead of the callable function. This url can either be external (ex. a placeholder generation site) or local (a local image within the template structure):</p> <p>data.json contents with a placeholder url:</p> <pre><code>{\n\"colored_rectangle_fn\": \"https://placehold.co/400\",\n\"rectangle_color\": \"\"\n}\n</code></pre> <p>data.json contents with a local image:</p> <pre><code>{\n\"colored_rectangle_fn\": \"/images/png_graphic.png\",\n\"rectangle_color\": \"\"\n}\n</code></pre>"},{"location":"build_templates/#extend-jinja2-by-using-a-custom-environment-wrapper-class","title":"Extend Jinja2 by using a custom Environment wrapper class","text":"<p>Starting with version 2.2.0, zipreport supports programmatic customization of the Environment() used by Jinja2 for template rendering, allowing injection or override of custom definitions such as filters, tests, etc. </p> <p>To create a custom Environment() wrapper, create a class inheriting from zipreport.template.EnvironmentWrapper, and override the method wrap() to provide the required behaviour: <pre><code>import markupsafe\nfrom jinja2 import Environment, pass_environment\nfrom zipreport.template import EnvironmentWrapper\n\n@pass_environment\ndef defoxifier(*args, **kwargs) -&gt; markupsafe.Markup:\n\"\"\"\n    Example filter that replaces \"fox\" with \"racoon\"\n    \"\"\"\n    al = len(args)\n    if al &lt; 2:\n        raise RuntimeError(\"Invalid number of arguments\")\n\n    text = args[1].replace(\"fox\", \"racoon\")\n    return markupsafe.Markup(text)\n\n\nclass MyCustomWrapper(EnvironmentWrapper):\n    def wrap(self, e: Environment) -&gt; Environment:\n        # perform Environment customization here\n        # in this case, register a custom filter\n        e.filters[\"defoxifier\"] = defoxifier\n\n        # return Environment\n        return e\n</code></pre></p> <p>The class can then be used to create the wrapper object, and passed to an existing processor: <pre><code># create custom wrapper object\nmy_wrapper = MyCustomWrapper()\n\n# render using zipreport processor\nprocessor = ZipReport(\"https://127.0.0.1:6543\", \"somePassword\") \nresult = processor.render_defaults(\n    report, \n    report_data, \n    wrapper=my_wrapper # our custom Environment wrapper \n)\n</code></pre></p>"},{"location":"build_templates/#page-numbers-headers-and-footers","title":"Page numbers, headers and footers","text":"<p>Page numbers, headers and footers can be generated automatically using paged.js. Please check paged.js documentation for detailed information on available formatting options and advanced usage.</p> <p>To ensure correct PDF generation, specially on lengthy or complex documents, it is recommended to always enable the js signaling functionality.</p>"},{"location":"build_templates/#including-pagedjs-on-your-report","title":"Including paged.js on your report","text":"<p>The most convenient way of including paged.js is to use the CDN link in your html report page:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;!-- PagedJS --&gt;\n    &lt;script src=\"https://unpkg.com/pagedjs/dist/paged.polyfill.js\"&gt;&lt;/script&gt;\n    &lt;style type=\"text/css\"&gt;\n&lt;!--\ncustom CSS rules goes here\n\n;\nsee below\n\n--&gt;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;!-- page content goes here --&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"build_templates/#adding-page-numbers","title":"Adding page numbers","text":"<p>Extending on our previous example, we can now add page numbers to the bottom right corner of the page via css:</p> <pre><code>@page {\n/* page footer */\n@bottom-right {\n/* page numbers will be prefixed by string \"page\" */\ncontent: \"page \" counter(page);\n}\n}\n</code></pre>"},{"location":"build_templates/#configuring-page-breaks","title":"Configuring page breaks","text":"<p>Forcing page breaks on specific sections is also possible. In this example, we will add page breaks for  tags: <pre><code>/* section tag triggers page break */\nsection {\nbreak-before: page;\n}\n</code></pre> <p>Now each section block will trigger a page break on our report:</p> <pre><code>(...)\n&lt;body&gt;\n&lt;section&gt;\n    &lt;h1&gt;this is page 1&lt;/h1&gt;\n&lt;/section&gt;\n\n&lt;section&gt;\n    &lt;h1&gt;this is page 2&lt;/h1&gt;\n&lt;/section&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"build_templates/#adding-a-header","title":"Adding a header","text":"<p>To add a header with the current chapter name, we map the heading tag (in this case, H1) to a variable, and then we extend our @page CSS definition to display that var on the top right corner of the page:</p> <pre><code>(\n...\n\n)\n\n@page {\n/* display 'title' contents in the top right corner of the page, in uppercase */\n@top-right {\ncontent: string(title);\ntext-transform: uppercase;\n}\n(...)\n}\n</code></pre>"},{"location":"build_templates/#adding-a-footer","title":"Adding a footer","text":"<p>Adding a static footer is similar to the approach used for page numbering. Just choose the desired page location and specify the desired content:</p> <pre><code>(\n...\n\n)\n@page {\n/* display static text on the footer */\n@bottom-center {\ncontent: \"sample footer\"\n}\n(...)\n}\n</code></pre>"},{"location":"build_templates/#complete-example","title":"Complete example","text":"<p>This is how our final version of a two-page report, with page numbers in the bottom right corner, a page header with the current chapter name in uppercase, and a fixed footer with a sample text looks like:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;!-- PagedJS --&gt;\n    &lt;script src=\"https://unpkg.com/pagedjs/dist/paged.polyfill.js\"&gt;&lt;/script&gt;\n    &lt;style type=\"text/css\"&gt;\n/* 'title' variable comes from h1 contents */\nh1 {\nstring-set: title content(text);\n}\n\n/* section tag triggers page break */\nsection {\nbreak-before: page;\n}\n\n@page {\n/* display 'title' contents in the top right corner of the page, in uppercase */\n@top-right {\ncontent: string(title);\ntext-transform: uppercase;\n}\n\n/* display static text on the footer */\n@bottom-center {\ncontent: \"sample footer\"\n}\n\n/* page footer */\n@bottom-right {\n/* page numbers will be prefixed by string \"page\" */\ncontent: \"page \" counter(page);\n}\n}\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;section&gt;\n    &lt;h1&gt;this is page 1&lt;/h1&gt;\n&lt;/section&gt;\n\n&lt;section&gt;\n    &lt;h1&gt;this is page 2&lt;/h1&gt;\n&lt;/section&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"build_templates/#advanced-usage","title":"Advanced usage","text":"<p>Visit paged.js documentation for more details on available features. An advanced example, with a cover page, sections and a table of contents can be found in the available examples.</p>"},{"location":"build_templates/#generating-table-of-contents-toc","title":"Generating table of contents (ToC)","text":"<p>ZipReport provides a simple example of automatic table of content generation with JavaScript and CSS in the examples section. It works by populating a div element with the desired index entries, and then use the CSS target-counter property to generate the page numbers.</p> <p>Lets build an example reusing both the js and css example files (originally they were provided by paged.js, but are no longer available). Copy both files to your report folder, and rename them to toc.js and toc.css respectively:</p> <pre><code>$ wget https://github.com/zipreport/zipreport/tree/master/examples/pagedjs/toc_example_report/js/toc.js -O toc.js\n$ wget https://github.com/zipreport/zipreport/tree/master/examples/pagedjs/toc_example_report/css/toc.css -O toc.css\n</code></pre> <p>We can then revisit and extend our previous example from page numbers:</p> <pre><code>(...)\n&lt;!-- PagedJS --&gt;\n&lt;script src=\"https://unpkg.com/pagedjs/dist/paged.polyfill.js\"&gt;&lt;/script&gt;\n&lt;!-- ToC script --&gt;\n&lt;script src=\"toc.js\"&gt;&lt;/script&gt;\n&lt;link href=\"toc.css\" rel=\"stylesheet\" type=\"text/css\"&gt;\n(..)\n</code></pre> <p>And add the index page to the body, and add a css class 'toc-element' to mark desired toc entries:</p> <pre><code>&lt;body&gt;\n&lt;!-- INDEX PAGE --&gt;\n&lt;section class=\"toc\"&gt;\n    &lt;h1&gt;Index&lt;/h1&gt;\n    &lt;div id=\"toc\"&gt;&lt;/div&gt;\n&lt;/section&gt;\n&lt;section&gt;\n    &lt;h1 class=\"toc-element\"&gt;this is page 1&lt;/h1&gt;\n&lt;/section&gt;\n\n&lt;section&gt;\n    &lt;h1 class=\"toc-element\"&gt;this is page 2&lt;/h1&gt;\n&lt;/section&gt;\n&lt;/body&gt;\n</code></pre> <p>And finally, hook both the dynamic ToC generation and ZipReport js signaling to the paged.js event handlers, just before closing the body tag:</p> <pre><code>    (...)\n&lt;script&gt;\nclass handlers extends Paged.Handler {\nconstructor(chunker, polisher, caller) {\nsuper(chunker, polisher, caller);\n}\n\nafterPreview(pages) {\n// signal zipreport PDF generation engine\nconsole.log('zpt-view-ready')\n}\n\nbeforeParsed(content) {\ncreateToc({\ncontent: content,\ntocElement: '#toc', // our target element\ntitleElements: ['.toc-element'] // CSS classes of elements to add to the index\n});\n}\n\n}\n\nPaged.registerHandlers(handlers);\n&lt;/script&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"cli/","title":"CLI tool: zipreport","text":"<p>ZipReport includes a cli tool to ease the process of creation and maintenance of report templates, zipreport.</p> <p>Available command-line arguments</p> Argument Description help Show usage information version [-m] Show version (or version number only, if -m) list [path] List report files on the current or specified path info  Show basic report details build  [output_file] [-s] Build a zpt file from a jinja template debug  [[host]:\\&lt;port&gt;] [-s] [-w path] Run debug server using the directory or specified file"},{"location":"cli/#list-report-files","title":"List report files","text":"<p>List all available report files:</p> <pre><code>$ zipreport list\nsample1.zpt          Sample report 1\n$\n</code></pre>"},{"location":"cli/#show-report-file-info","title":"Show report file info","text":"<pre><code>$ zipreport info sample1.zpt\nsample1.zpt          Sample report 1\n$\n</code></pre>"},{"location":"cli/#generate-a-report-file","title":"Generate a report file","text":"<p>Generating a report file (zpt) from existing Jinja2 report files (the option -s can be used if templates use symlinks):</p> <pre><code>$ zipreport build reports/sample1 sample1-1.0.0\n== Building Report sample1-1.0.0.zpt ==\nFollow Symlinks: False\nChecking manifest &amp; index file...\nBuilding...\nCopying manifest.json...\nCopying index.html...\nCopying data.json...\nCopying partials/base.html...\nGenerating sample1-1.0.0.zpt...\nDone!\n$\n</code></pre>"},{"location":"cli/#running-a-template-for-development-purposes-debugging","title":"Running a template for development purposes (debugging)","text":"<p>The debug argument creates a local webserver to run a given Jinja template or report file. At each page request ( refresh) it will re-render the template as HTML.</p> <p>To use debug with a template that uses symbolic links, the -s option must be used.</p> <p>Please note, the template should have a valid manifest.json and data.json files. If no data.json is present and variables are required to render the template, the render will fail. See building templates for more information.</p> <pre><code>$ zipreport debug reports/sample1/\nStarted debug server at http://localhost:8001\nServing from: reports/sample1\nUse Ctrl+C to stop...\n</code></pre>"},{"location":"cli/#using-zipreport-debug-with-a-custom-environment-wrapper","title":"Using zipreport debug with a custom Environment wrapper","text":"<p>Starting with version 2.2.0, zipreport supports using a custom class as a Jinja2 Environment wrapper. To use the custom environment wrapper, zipreport debug needs to be able to initialize the object during execution time. The wrapper can either be provided by an already existing module namespace, or by creating a local file with the class definition:</p> value example description mymodule.class-name appmodule.MyWrapper uses class-name in mymodule as a wrapper local-file.class-name myfile.MyWrapper uses class-name in local-file as a wrapper <p>The wrapper path value can then be passed to zipreport-debug using the -w argument:</p> <pre><code>$ zipreport debug -w mymodule.class-name reports/sample1/\nStarted debug server at http://localhost:8001\nServing from: reports/sample1\nUse Ctrl+C to stop...\n</code></pre> <p>An example of a custom wrapper file suitable for zipreport debug can be found here. </p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#why-another-pdf-generation-library","title":"Why another PDF generation library?","text":"<p>While there are many excellent free and open source libraries for report generation, Python seems to be a  second-class citizen - existing libraries are either old/unmaintained or quite slow while supporting only a  subset of features. ZipReport aims to be a faster alternative, while supporting modern HTML/CSS and JavaScript.</p>"},{"location":"faq/#what-are-the-typical-usage-scenarios","title":"What are the typical usage scenarios?","text":"<ul> <li>Custom reports, mixing static and generated data;</li> <li>Dashboarding reports with dynamic composition via JavaScript;</li> <li>Transactional emails that require embedding of images (ex daily server reports with graphics);</li> </ul>"},{"location":"faq/#does-it-run-on-windows-or-mac-os-x","title":"Does it run on Windows or Mac OS X?","text":"<p>ZipReport was only tested on Linux systems.</p>"},{"location":"faq/#what-htmlcssjs-features-are-supported","title":"What HTML/CSS/JS features are supported?","text":"<p>When using zipreport-server, the rendering is executed by Chromium; all features supported by a modern Chromium browsers can be used. When using WeasyPrint, basic WeasyPrint features ate supported.</p>"},{"location":"faq/#is-it-fast","title":"Is it fast?","text":"<p>Depends on the defintion of \"fast\". The complex report example may take 2-3 seconds to process. Huge documents may take longer.</p>"},{"location":"faq/#is-it-thread-safe","title":"Is it thread-safe?","text":"<p>No. While zipreport can be used safely to render reports inside threads,  the report processing subsystem is not thread safe. We recommend not to share ZipReport objects or state between threads.</p>"},{"location":"faq/#does-it-work-with-alternative-python-implementations-besides-cpython","title":"Does it work with alternative Python implementations besides cPython?","text":"<p>It was only tested with cPython. It may work, or it may not.</p>"},{"location":"how_it_works/","title":"How it works","text":"<p>ZipReport relies on two core concepts: Report Files and Processors. The rendering is executed in two stages - first, the result of rendering the Jinja template is generated and stored within the memory representation of the report file with the name report.html. Then, the in-memory report file is passed to a Processor, to be rendered onto its final form - either PDF or MIME message. Content, such as dynamically generated images is also embedded on the in-memory report file. It is also possible to add extra files at runtime, before passing it to the desired processor. However, replacement of existing files is not allowed.</p>"},{"location":"how_it_works/#report-files","title":"Report Files","text":"<p>A report file is a Jinja template, a manifest file and an optional data file packed into a zip file, usually with .zpt extension. These files can be easily generated with the zipreport cli tool. For more information on the cli tool, check the cli documentation</p> <p>For a Jinja template to be packed into a report file (and be a valid report), it needs to contain a manifest. A manifest is a JSON file called manifest.json, that contains basic report information, such as title and mandatory template variables. The template may also contain a data.json file, that will be used when debugging (zipreport debug) the template. This file provides placeholder data for the required fields, for previewing purposes.</p> <p>The main Jinja template file must be named index.html. A template cannot contain a file called named report.html. This is a reserved name, used to store the result of the Jinja rendering. The template can also include other files, such as partials, css resources, javascript resources, images or fonts.</p> <p>Example of structure from examples/reports/simple:</p> <pre><code>$ cd examples/reports/simple\n.\n\u251c\u2500\u2500 css\n\u2502   \u2514\u2500\u2500 style.css\n\u251c\u2500\u2500 data.json\n\u251c\u2500\u2500 index.html\n\u251c\u2500\u2500 manifest.json\n\u2514\u2500\u2500 partials\n    \u2514\u2500\u2500 base.html\n\n2 directories, 5 files\n$\n</code></pre>"},{"location":"how_it_works/#supporting-symbolic-links-min-version-210","title":"Supporting symbolic links (min version: 2.1.0)","text":"<p>The template file tree is often a well-defined, contained structure. Starting with version 2.1.0, to allow eg. sharing of resources between templates, the usage of symbolic links is supported in both zipreport debug and zipreport build. By using -s, the commands will follow and process any related symlinks, as long as they are linked within the structure of the template.</p>"},{"location":"how_it_works/#report-file-format-zpt","title":"Report file format (zpt)","text":"<p>ZipReport report files (*.zpt) are just regular zip files with - at least - the following entries:</p> File Mandatory Description index.html yes Report template main file manifest.json yes Report manifest file. Contains report information such as title, description and mandatory parameters data.json no Optional data file to be used when debugging the template <p>For more details on these files, see below.</p>"},{"location":"how_it_works/#manifest-file-manifestjson","title":"Manifest file: manifest.json","text":"<p>The manifest.json is a regular JSON file. Its structure is as follows:</p> Field Type Description author string Report author identification title string Report title description string Extended description version string ZipReport engine version (currently ignored) useJSEvent string If \"true\", will automatically use jsEvent with ZipReport =cli/server params list List of mandatory parameter names. When rendering the report, will generate an exception if the passed parameter keys does not match this list <p>Additionally, the manifest can contain other fields relevant to the application, they are just ignored by ZipReport. If other fields exist, they can be accessed from the application on certain usage patterns.</p> <p>Example of manifest.json from examples/reports/simple:</p> <pre><code>    {\n\"author\": \"jpinheiro\",\n\"title\": \"Simple Report\",\n\"description\": \"Simple ZipReport Report\",\n\"version\": \"1.0\",\n\"params\": [\n\"title\",\n\"color_list\",\n\"description\"\n]\n}\n</code></pre> <p>In this example, to render the report, it is necessary to pass a dict containing the keys specified in params. The dict may contain other keys. If the keys specified in the manifest are not present, rendering will generate a RuntimeError exception.</p>"},{"location":"how_it_works/#data-placeholder-file-datajson","title":"Data placeholder file: data.json","text":"<p>The data placeholder file is an optional JSON file named data.json. It contains a dictionary of predefined values for the required params specified in the manifest file. This is used to aid the design and preview of the reports, during development. It is ignored when used outside the scope of zipreport debug.</p> <p>Example of data.json from examples/reports/simple, for the manifest in the previous example:</p> <pre><code>{\n\"title\": \"Simple report with Jinja templating\",\n\"color_list\": [\n\"red\",\n\"blue\",\n\"green\",\n\"yellow\",\n\"orange\",\n\"pink\",\n\"green\"\n],\n\"description\": \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ut ornare metus.\"\n}\n</code></pre>"},{"location":"how_it_works/#main-template-file-indexhtml","title":"Main template file: index.html","text":"<p>This is the Jinja template entrypoint for rendering. It can reference local resources residing below the template folder in the filesystem hierarchy (meaning it is not possible to use partials from another template), or external resources such as javascript libraries, css frameworks or fonts.</p> <p>Example of index.html from examples/reports/simple, using a partial (partials/base.html) as wel as some Jinja template expressions:</p> <pre><code>{% extends 'partials/base.html' %}\n\n{% block title%}\n{{ title }}\n{% endblock %}\n\n{% block content %}\n&lt;h1&gt;{{ title }} : main&lt;/h1&gt;\n&lt;h2&gt;Some custom text:&lt;/h2&gt;\n&lt;p&gt;\n    {{ description }}\n&lt;/p&gt;\n&lt;h2&gt;A list of colors:&lt;/h2&gt;\n&lt;ul&gt;\n    {% for item in color_list %}\n    &lt;li&gt;Color: {{ item }}&lt;/li&gt;\n    {% endfor %}\n&lt;/ul&gt;\n{% endblock %}\n</code></pre>"},{"location":"how_it_works/#processors","title":"Processors","text":"<p>Processors are classes that implements zipreport.processors.ProcessorInterface. Their role is to interact with a backend and generate a PDF file or a MIME message. The generation result is never an actual file but a io.BytesIO buffer that can easily be stored to disk or streamed to a client.</p> <p>Processors can be used directly or via convenient helper classes that wrap both Jinja rendering logic and processor invocation.</p>"},{"location":"how_it_works/#available-processors","title":"Available Processors","text":"<p>There are several available processors to interact with the different backend options. You can also easily create your own, if necessary. Just implement a new class that implements  zipreport.processors.ProcessorInterface.</p> Class Description zipreport.processors.ZipReportProcessor zipreport-server API PDF report generation zipreport.processors.MIMEProcessor MIME email report generation zipreport.processors.weasyprint.WeasyPrintProcessor WeasyPrint PDF report generation"},{"location":"how_it_works/#processor-interface","title":"Processor Interface","text":"<p>zipreport.processors.ProcessorInterface specifies a single method:</p> <pre><code>ProcessorInterface.process(self, job: ReportJob) -&gt; JobResult:\n</code></pre> <p>This method receives a zipreport.report.ReportJob object. This object contains all PDF-related options such as margins and page size, as well as the required ReportFile. It returns a zipreport.report.JobResult object, with the status of the operation, error information (if any), and the result buffer.</p>"},{"location":"how_it_works/#helper-classes","title":"Helper Classes","text":"<p>Helper classes encapsulate both the processor logic and the Jinja rendering logic. The following helper classes are available:</p> Class Description zipreport.ZipReport ZipReportProcessor helper zipreport.MIMEReport MIMEProcessor helper <p>See below for usage examples for each processor.</p>"},{"location":"how_it_works/#zipreportprocessor","title":"ZipReportProcessor","text":"<p>ZipReportProcessor interacts with the zipreport-server API to generate a PDF. From a development perspective, all required operations are done in-memory and no local storage is needed.</p> <p>Constructor:</p> <pre><code>ZipReportProcessor(client: ZipReportClient)\n</code></pre> <p>client is an instance of zipreport.processors.ZipReportClient, whose function is to encapsulate API communication logic.</p> <p>ZipReportProcessor example:</p> <pre><code>from zipreport.processors import ZipReportProcessor, ZipReportClient\nfrom zipreport.report import ReportFileLoader, ReportJob\nfrom zipreport.template import JinjaRender\n\n# output file\noutput_file = \"result.pdf\"\n\n# template variables\nreport_data = {\n    'title': \"Example report using Jinja templating\",\n    'color_list': ['red', 'blue', 'green'],\n    'description': 'a long text field with some filler description',\n}\n\n# load report from file\nzpt = ReportFileLoader.load(\"simple.zpt\")\n\n# initialize api client\napi_client = ZipReportClient(\"https://127.0.0.1:6543\", \"secretKey\")\n\n# first step:\n# render the template using the report_data dict\n# the result of the rendering is stored in-memory within the zpt file, with the name\n# report.html\nJinjaRender(zpt).render(report_data)\n\n# create a rendering job from the zpt file\njob = ReportJob(zpt)\n\n# second step:\n# generate a PDF by calling the processor, using the API client\n# this method returns a JobResult\nresult = ZipReportProcessor(api_client).process(job)\n\n# if PDF generation was successful, save to file\nif result.success:\n    with open(output_file, 'wb') as rpt:\n        rpt.write(result.report.read())\n</code></pre>"},{"location":"how_it_works/#using-zipreport-helper","title":"Using ZipReport Helper","text":"<p>ZipReportProcessor can also be used in a simplified fashion, by using the helper class ZipReport. This class will create an API client, as well as a default ReportJob, simplifying the code implementation.</p> <p>Constructor:</p> <pre><code>ZipReport(url: str, api_key: str, api_version: int = 2, secure_ssl: bool = False)\n</code></pre> <p>url is the API endpoint url, api_key is the API authentication token, and secure_ssl enables or disables full certificate chain verification on SSL certificates for HTTPS endpoints. api_version specifies the API version to connect; currently, only v2 is implemented.</p> <p>Code example:</p> <pre><code>from zipreport import ZipReport\nfrom zipreport.report import ReportFileLoader\n\n# output file\noutput_file = \"result.pdf\"\n\n# template variables\nreport_data = {\n    'title': \"Example report using Jinja templating\",\n    'color_list': ['red', 'blue', 'green'],\n    'description': 'a long text field with some filler description',\n}\n\n# load report from file\nzpt = ReportFileLoader.load(\"reports/simple.zpt\")\n\n# render the report using ZipReport helper class\nresult = ZipReport(\"https://127.0.0.1:6543\", \"someSecret\").render_defaults(zpt, report_data)\n\n# if PDF generation was successful, save file\nif result.success:\n    with open(output_file, 'wb') as rpt:\n        rpt.write(result.report.read())\n</code></pre>"},{"location":"how_it_works/#mimeprocessor","title":"MimeProcessor","text":"<p>MIMEProcessor generates a multipart MIME email message with all local resources embedded. It requires no local storage.</p> <p>Constructor:</p> <pre><code>MIMEProcessor()\n</code></pre> <p>MIMEProcessor example:</p> <pre><code>from zipreport.processors import MIMEProcessor\nfrom zipreport.report import ReportFileLoader, ReportJob\nfrom zipreport.template import JinjaRender\n\n# output file\noutput_file = \"result.eml\"\n\n# template variables\nreport_data = {\n    'title': \"Example report using Jinja templating\",\n    'color_list': ['red', 'blue', 'green'],\n    'description': 'a long text field with some filler description',\n}\n\n# load report from file\nzpt = ReportFileLoader.load(\"simple.zpt\")\n\n# first step:\n# render the template using the report_data dict\n# the result of the rendering is stored in-memory within the zpt file, with the name\n# report.html\nJinjaRender(zpt).render(report_data)\n\n# create a rendering job from the zpt file\njob = ReportJob(zpt)\n\n# second step:\n# generate a MIME message by calling the processor\n# this method returns a JobResult\nresult = MIMEProcessor().process(job)\n\n# if message generation was successful, save to file\nif result.success:\n    with open(output_file, 'wb') as rpt:\n        # result.report is of type EmailMessage, not io.BytesIO\n        rpt.write(result.report.as_bytes())\n</code></pre>"},{"location":"how_it_works/#using-mimeprocessor-helper","title":"Using MIMEProcessor Helper","text":"<p>MIMEProcessor can also be used in a simplified fashion, by using the helper class MIMEReport. This class will create a default ReportJob&lt;zipreport.reports.job.ReportJob, simplifying the PDF generation process.</p> <p>Constructor:</p> <pre><code>MIMEReport()\n</code></pre> <p>Code example:</p> <pre><code>from zipreport import MIMEReport\nfrom zipreport.report import ReportFileLoader\n\n# output file\noutput_file = \"result.eml\"\n\n# template variables\nreport_data = {\n    'title': \"Example report using Jinja templating\",\n    'color_list': ['red', 'blue', 'green'],\n    'description': 'a long text field with some filler description',\n}\n\n# load report from file\nzpt = ReportFileLoader.load(\"reports/simple.zpt\")\n\n# render the report with default job options, using the helper class\nresult = MIMEReport().render_defaults(zpt, report_data)\n\nif result.success:\n    with open(output_file, 'wb') as rpt:\n        # result.report is of type EmailMessage, not io.BytesIO\n        rpt.write(result.report.as_bytes())\n</code></pre>"},{"location":"how_it_works/#weasyprintprocessor","title":"WeasyPrintProcessor","text":"<p>WeasyPrintProcessor relies on WeasyPrint for PDF generation. By using WeasyPrint, client-side Javascript is not supported, and CSS support is limited. Check WeasyPrint website for more details. Details on how to install ZipReport with WeasyPrint support can be found in the installation instructions.</p> <p>Constructor:</p> <pre><code>WeasyPrintProcessor()\n</code></pre> <p>The WeasyPrintProcessor includes some additional methods to map WeasyPrint basic requirements to ZipReport processor logic:</p> <pre><code>WeasyPrintProcessor.add_css(self, css)\n</code></pre> <p>where css is a WeasyPrint CSS object; see example below</p> <p>Example:</p> <pre><code>from zipreport.processors.weasyprint import WeasyPrintProcessor\nfrom weasyprint import CSS\n\nprocessor = WeasyPrintProcessor()\nprocessor.add_css(CSS(string='body { font-family: serif !important }'))\n</code></pre> <pre><code>WeasyPrintProcessor.set_font_config(self, font_config)\n</code></pre> <p>font_config is a FontConfiguration() object. See WeasyPrint documentation for more details</p> <p>Example:</p> <pre><code>from zipreport.processors.weasyprint import WeasyPrintProcessor\nfrom weasyprint import CSS\nfrom weasyprint.fonts import FontConfiguration\n\nprocessor = WeasyPrintProcessor()\nfont_config = FontConfiguration()\n# taken from WeasyPrint tutorial in https://weasyprint.readthedocs.io/en/stable/tutorial.html\ncss = CSS(string='''\n@font-face {\n    font-family: Gentium;\n    src: url(http://example.com/fonts/Gentium.otf);\n}\nh1 { font-family: Gentium }''', font_config=font_config)\nprocessor.add_css(css)\nprocessor.set_font_config(font_config)\n</code></pre> <p>WeasyPrintProcessor example:</p> <pre><code>from zipreport.processors.weasyprint import WeasyPrintProcessor\nfrom zipreport.report import ReportFileLoader, ReportJob\nfrom zipreport.template import JinjaRender\n\n# output file\noutput_file = \"result.pdf\"\n\n# template variables\nreport_data = {\n    'title': \"Example report using Jinja templating\",\n    'color_list': ['red', 'blue', 'green'],\n    'description': 'a long text field with some filler description',\n}\n\n# load report from file\nzpt = ReportFileLoader.load(\"simple.zpt\")\n\n# first step:\n# render the template using the report_data dict\n# the result of the rendering is stored in-memory within the zpt file, with the name\n# report.html\nJinjaRender(zpt).render(report_data)\n\n# create a rendering job from the zpt file\njob = ReportJob(zpt)\n\n# second step:\n# generate a PDF by calling the processor, using the API client\n# this method returns a JobResult\nresult = WeasyPrintProcessor().process(job)\n\n# if PDF generation was successful, save to file\nif result.success:\n    with open(output_file, 'wb') as rpt:\n        rpt.write(result.report.read())\n</code></pre> <p>Note: This processor does not have a helper class, to avoid having WeasyPrint as a required ZipReport dependency.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#required-dependencies","title":"Required dependencies","text":"<ul> <li>jinja2_ &gt;= 3.1</li> <li>requests_ &gt;= 2.22.0</li> <li>WeasyPrint_ &gt;= 58.0 (optional, see below)</li> </ul>"},{"location":"install/#step-1-install-zipreport-library","title":"Step 1: install ZipReport library","text":"<p>To install ZipReport library, use pip:</p> <pre><code>$ python3 -m pip install zipreport-lib\n</code></pre> <p>Or if WeasyPrint backend is required, install:</p> <pre><code>$ python3 -m pip install zipreport-lib[weasyprint]\n</code></pre>"},{"location":"install/#step-2-choose-and-install-a-rendering-backend","title":"Step 2: choose and install a rendering backend","text":""},{"location":"install/#available-backends","title":"Available backends:","text":"<ul> <li>ZipReport-Server, an API-based PDF rendering server (recommended)</li> <li>WeasyPrint, experimental, available for compatibility purposes only</li> <li>MIME, an internal MIME Processor that has no external dependencies</li> </ul>"},{"location":"install/#using-zipreport-server","title":"Using zipreport-server","text":"<p>ZipReport communicates with zipreport-server via REST API, using multipart/form-data format. Check the  zipreport-server repository for additional details and setup configuration.</p> <p>On AMD64 systems, an existing prebuilt Docker image can be used. Don't forget to change your API key, used for  autentication.</p> <pre><code> $ docker run -d -p 6543:6543 ghcr.io/zipreport/zipreport-server:latest \\\n-e ZIPREPORT_API_KEY=\"my-api-mey\" </code></pre>"},{"location":"install/#installing-from-source","title":"Installing from source","text":"<p>Clone the ZipReport repository: <pre><code>$ git clone https://github.com/zipreport/zipreport.git\n</code></pre></p> <p>Install the package: <pre><code>$ python3 setup.py install\n</code></pre></p>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#latest-changes","title":"Latest Changes","text":""},{"location":"release-notes/#200","title":"2.0.0","text":""},{"location":"release-notes/#features","title":"Features","text":"<ul> <li>Removal of ZipReport-Cli and WkHtml2Pdf Processors;</li> <li>Added support for zipreport-server v2.0.0 - this is now the preferred processor;</li> <li>Updated examples and unit tests;</li> <li>Removed/updated ReportJob parameters to match zipreport-server usage;</li> <li>Increased minimum supported Python version to 3.8;</li> </ul>"},{"location":"release-notes/#110","title":"1.1.0","text":""},{"location":"release-notes/#features_1","title":"Features","text":"<ul> <li>ZipReportCli() now supports optional cli arguments to be passed to the zpt-cli binary;</li> <li>Code formatting;</li> </ul>"},{"location":"security/","title":"Security considerations","text":"<p>While your reports can reference external resources such as JavaScript files, images, CSS and fonts just like any regular HTML page, keep in mind this may expose your system to security threats. To mimimize this possibility, you should not reference external resources you don't own or trust.</p> <p>The zipreport-server daemon also creates temporary HTTP servers on each rendering request; these servers may expose sensitive information, so appropriate protection measures (such as running zipreport-server in a Docker container) are recommended.</p>"}]}